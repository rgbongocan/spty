#!/home/renzo/spotlite/spotlite-env/bin/python

import argcomplete
import argparse
import inspect
import re

from argcomplete.completers import ChoicesCompleter
from sys import argv

from client import get_spotify_client
from play import play_commands
from volume import volume_commands


spfy = None


def share(args) -> None:
    item = spfy.current_playback()["item"]
    if (format := args.format) in {"url", None}:
        print(item["external_urls"]["spotify"])
    if format in {"uri", None}:
        print(item["uri"])


def status(args) -> None:
    playback = spfy.current_playback()
    track = playback["item"]
    title = track["name"]
    album = track["album"]["name"]
    artists = ", ".join([a["name"] for a in track["artists"]])

    info = args.info
    if info == "track":
        print(title)
    elif info == "album":
        print(album)
    elif info == "artist":
        print(artists)
    else:
        progress = ms_to_duration(playback["progress_ms"])
        duration = ms_to_duration(track["duration_ms"])
        label = "Artists" if len(track["artists"]) > 1 else "Artist"
        print(
            inspect.cleandoc(
                f"""
                Title: {title}
                Album: {album}
                {label}: {artists}
                {progress} / {duration}"""
            )
        )


def ms_to_duration(milliseconds: int) -> str:
    """
    Converts milliseconds into a human-readable duration format
    """
    seconds = milliseconds // 1000
    minutes, seconds = divmod(seconds, 60)
    return "{:02d}:{:02d}".format(minutes, seconds)


def shuffle(args) -> None:
    if (state := args.state) == "on":
        spfy.shuffle(True)
    elif state == "off":
        spfy.shuffle(False)
    else:
        spfy.shuffle(not spfy.current_playback()["shuffle_state"])


def replay():
    spfy.seek_track(0)
    spfy.play()


def repeat(args):
    spfy.repeat(args.state)


def pause():
    if spfy.current_playback()["is_playing"]:
        spfy.pause_playback()


def nxt():
    spfy.next_track()


def prev():
    spfy.previous_track()


def stop():
    pause(None)
    replay(None)


def shift(seconds: int):
    progress_ms = spfy.current_playback()["progress_ms"]
    spfy.seek_track(progress_ms + seconds * 1000)


def fast_forward(args):
    shift(args.seconds or 10)


def rewind(args):
    shift(-(args.seconds or 10))


def seconds_type(arg):
    if not arg.isdigit():
        raise argparse.ArgumentTypeError("Optional argument must be a positive integer")
    return int(arg)


def seek(arg):
    spfy.seek_track(arg.time)


def time_type(arg) -> int:
    """
    Converts a valid timestamp in `minutes:seconds` format into milliseconds
    """
    prog = re.compile("^([0-5]?[0-9]):([0-6]{1}[0-9]{1})$")
    match = prog.search(arg)
    if not match:
        raise argparse.ArgumentTypeError("Not a valid timestamp")
    if match:
        minutes = int(match.group(1))
        seconds = int(match.group(2))
        return ((60 * minutes) + seconds) * 1000


no_args = {"replay", "pause", "next", "prev", "stop", "up", "down"}

if __name__ == "__main__":
    parser = argparse.ArgumentParser(
        prog="spotlite", description="Issue spotify commands"
    )
    subp = parser.add_subparsers(dest="subparser_name")

    play_commands(
        subp.add_parser("play", help="Play a song, album, playist, or resume playback")
    )
    volume_commands(
        subp.add_parser("vol", aliases=["volume"], help="Show/adjust volume")
    )

    subp.add_parser("next", help="Skip to next track").set_defaults(func=nxt)
    subp.add_parser(
        "prev", aliases=["previous"], help="Replay the previous track"
    ).set_defaults(func=prev)
    subp.add_parser("replay", help="Replay the current track").set_defaults(func=replay)
    subp.add_parser("pause", help="Pause playback").set_defaults(func=pause)
    subp.add_parser("stop", help="Stop playback").set_defaults(func=stop)

    sp_ffwd = subp.add_parser(
        "ffwd",
        aliases=["fast-forward"],
        help="Fast forward by n seconds (10 by default)",
    )
    sp_ffwd.set_defaults(func=fast_forward)
    sp_ffwd.add_argument("seconds", nargs="?", type=seconds_type)

    sp_rewind = subp.add_parser(
        "rew", aliases=["rewind"], help="Rewind by n seconds (10 by default)"
    )
    sp_rewind.set_defaults(func=rewind)
    sp_rewind.add_argument("seconds", nargs="?", type=seconds_type)

    sp_seek = subp.add_parser(
        "seek", help="Move current song to a timestamp (e.g. 01:30)"
    )
    sp_seek.set_defaults(func=seek)
    sp_seek.add_argument("time", type=time_type)

    subp_share = subp.add_parser("share", help="Show share url/uri")
    subp_share.set_defaults(func=share)
    subp_share.add_argument("format", type=str, nargs="?", choices={"url", "uri"})

    subp_status = subp.add_parser("status", help="Show current playback information")
    subp_status.set_defaults(func=status)
    subp_status.add_argument(
        "info", type=str, nargs="?", choices={"track", "album", "artist"}
    )

    subp_shuffle = subp.add_parser("shuffle", help="Toggle shuffle state")
    subp_shuffle.set_defaults(func=shuffle)
    subp_shuffle.add_argument("state", type=str, nargs="?", choices={"on", "off"})

    subp_repeat = subp.add_parser("repeat", help="Toggle repeat state")
    subp_repeat.set_defaults(func=repeat)
    subp_repeat.add_argument("state", type=str, choices={"track", "context", "off"})

    subp.completer = ChoicesCompleter(subp.choices.keys())
    argcomplete.autocomplete(parser)

    # hax
    args = argv[1:]
    # if len(args) > 0:
    if args[0] in {"vol", "volume"} and len(args) > 1 and args[1].isdigit():
        args.insert(1, "set")

    # also hax
    if args[0] == "play" and len(args) > 1 and args[1] not in {"album", "list"}:
        args.insert(1, "track")

    # to exclude files and directories from tab completion
    args = parser.parse_args(args)
    spfy = get_spotify_client()
    if args.subparser_name in no_args:
        args.func()
    else:
        args.func(args)
