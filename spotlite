#!/home/renzo/spotlite/spotlite-env/bin/python

import argcomplete, argparse
import inspect
import re
import spotipy
import spotipy.util as util

from argcomplete.completers import ChoicesCompleter


CLIENT_ID = "23503e502dd54c53a15e50d8f4bc9ecc"
CLIENT_SECRET = "b69d6ad88e334a52abd05dc688ebd906"
REDIRECT_URI = "http://localhost:9090/"
SCOPES = [
    "user-read-playback-state",
    "user-read-currently-playing",
    "user-modify-playback-state",
    "user-library-read",
]

username = "count_gbrl"
spfy = None


def volume_type(arg: str) -> None:
    if arg in {"up", "down"}:
        return arg
    elif arg.isdigit() and (volume := int(arg)) < 101:
        return volume
    raise argparse.ArgumentTypeError(
        "Must be `up`, `down`, or an integer from 0 to 100"
    )


def volume(args) -> None:
    current = spfy.current_playback()["device"]["volume_percent"]
    volume = args.vol
    if volume == "up":
        if current == 100:
            print("Already at max volume")
        else:
            to = min(current + 10, 100)
            spfy.volume(to)
            print(f"Volume increased to {to}")
    elif volume == "down":
        if current == 0:
            print("Already muted")
        else:
            to = max(0, current - 10)
            spfy.volume(to)
            print(f"Volume decreased to {to}")
    elif isinstance(volume, int):
        spfy.volume(volume)
    else:
        print(current)


def share(args) -> None:
    item = spfy.current_playback()["item"]
    if (format := args.format) in {"url", None}:
        print(item["external_urls"]["spotify"])
    if format in {"uri", None}:
        print(item["uri"])


def status(args) -> None:
    playback = spfy.current_playback()
    track = playback["item"]
    title = track["name"]
    album = track["album"]["name"]
    artists = ", ".join([a["name"] for a in track["artists"]])

    info = args.info
    if info == "track":
        print(title)
    elif info == "album":
        print(album)
    elif info == "artist":
        print(artists)
    else:
        progress = ms_to_duration(playback["progress_ms"])
        duration = ms_to_duration(track["duration_ms"])
        label = "Artists" if len(track["artists"]) > 1 else "Artist"
        print(
            inspect.cleandoc(
                f"""
                Title: {title}
                Album: {album}
                {label}: {artists}
                {progress} / {duration}"""
            )
        )


def ms_to_duration(milliseconds: int) -> str:
    """
    Converts milliseconds into a human-readable duration format
    """
    seconds = milliseconds // 1000
    minutes, seconds = divmod(seconds, 60)
    return "{:02d}:{:02d}".format(minutes, seconds)


def play(args) -> None:
    if t := args.track:
        track = " ".join(t)
        res = spfy.search(track, limit=1)
        if items := res["tracks"]["items"]:
            spfy.start_playback(uris=[items[0]["uri"]])
        else:
            print("No matches found")
            return
    elif a := args.album:
        album = " ".join(a)
        res = spfy.search(album, limit=1, type="album")
        if items := res["albums"]["items"]:
            spfy.start_playback(context_uri=items[0]["uri"])
        else:
            print("No matches found")
            return
    elif ls := args.list:
        playlist = " ".join(ls)
        res = spfy.search(playlist, limit=1, type="playlist")
        if items := res["playlists"]["items"]:
            spfy.start_playback(context_uri=items[0]["uri"])
        else:
            print("No matches found")
            return
    elif not spfy.current_playback()["is_playing"]:
        spfy.start_playback()


def shuffle(args) -> None:
    if (state := args.state) == "on":
        spfy.shuffle(True)
    elif state == "off":
        spfy.shuffle(False)
    else:
        spfy.shuffle(not spfy.current_playback()["shuffle_state"])


def replay():
    spfy.seek_track(0)
    spfy.play()


def repeat(args):
    spfy.repeat(args.state)


def pause():
    if spfy.current_playback()["is_playing"]:
        spfy.pause_playback()


def nxt():
    spfy.next_track()


def prev():
    spfy.previous_track()


def stop():
    pause(None)
    replay(None)


def shift(seconds: int):
    progress_ms = spfy.current_playback()["progress_ms"]
    spfy.seek_track(progress_ms + seconds * 1000)


def fast_forward(args):
    shift(args.seconds or 10)


def rewind(args):
    shift(-(args.seconds or 10))


def seconds_type(arg):
    if not arg.isdigit():
        raise argparse.ArgumentTypeError("Optional argument must be a positive integer")
    return int(arg)


def seek(arg):
    spfy.seek_track(arg.time)


def time_type(arg) -> int:
    """
    Converts a valid timestamp in `minutes:seconds` format into milliseconds
    """
    prog = re.compile("^([0-5]?[0-9]):([0-6]{1}[0-9]{1})$")
    match = prog.search(arg)
    if not match:
        raise argparse.ArgumentTypeError("Not a valid timestamp")
    if match:
        minutes = int(match.group(1))
        seconds = int(match.group(2))
        return ((60 * minutes) + seconds) * 1000


no_args = {"replay", "pause", "next", "prev", "stop"}

if __name__ == "__main__":
    parser = argparse.ArgumentParser(
        prog="spotlite", description="Issue spotify commands"
    )
    subp = parser.add_subparsers(dest="sp_name")

    # print(u"\u23ed")
    subp.add_parser("next", help="Skip to next track").set_defaults(func=nxt)
    subp.add_parser("prev", help="Replay the previous track").set_defaults(func=prev)
    subp.add_parser("replay", help="Replay the current track").set_defaults(func=replay)
    subp.add_parser("pause", help="Pause playback").set_defaults(func=pause)
    subp.add_parser("stop", help="Stop playback").set_defaults(func=stop)

    sp_ffwd = subp.add_parser("ffwd", help="Fast forward by n seconds (10 by default)")
    sp_ffwd.set_defaults(func=fast_forward)
    sp_ffwd.add_argument("seconds", nargs="?", type=seconds_type)

    sp_rewind = subp.add_parser("rew", help="Rewind by n seconds (10 by default)")
    sp_rewind.set_defaults(func=rewind)
    sp_rewind.add_argument("seconds", nargs="?", type=seconds_type)

    sp_seek = subp.add_parser(
        "seek", help="Move current song to a timestamp (e.g. 01:30)"
    )
    sp_seek.set_defaults(func=seek)
    sp_seek.add_argument("time", type=time_type)

    subp_play = subp.add_parser(
        "play", help="Resume playback; Play a song/album/playist"
    )
    subp_play.set_defaults(func=play)
    subp_play.add_argument(
        "track", default="", type=str, nargs=argparse.REMAINDER, metavar="track"
    )
    group_play = subp_play.add_mutually_exclusive_group()
    group_play.add_argument(
        "--album", help="Play an album", type=str, nargs="+", metavar="album"
    )
    group_play.add_argument(
        "--list", help="Play a playlist", type=str, nargs="+", metavar="list"
    )

    subp_vol = subp.add_parser("vol", help="Show/adjust volume")
    subp_vol.set_defaults(func=volume)
    subp_vol.add_argument("vol", nargs="?", type=volume_type)

    subp_share = subp.add_parser("share", help="Show share url/uri")
    subp_share.set_defaults(func=share)
    subp_share.add_argument("format", type=str, nargs="?", choices={"url", "uri"})

    subp_status = subp.add_parser("status", help="Show current playback information")
    subp_status.set_defaults(func=status)
    subp_status.add_argument(
        "info", type=str, nargs="?", choices={"track", "album", "artist"}
    )

    subp_shuffle = subp.add_parser("shuffle", help="Toggle shuffle state")
    subp_shuffle.set_defaults(func=shuffle)
    subp_shuffle.add_argument("state", type=str, nargs="?", choices={"on", "off"})

    subp_repeat = subp.add_parser("repeat", help="Toggle repeat state")
    subp_repeat.set_defaults(func=repeat)
    subp_repeat.add_argument("state", type=str, choices={"track", "context", "off"})

    token = util.prompt_for_user_token(
        username,
        scope=" ".join(SCOPES),
        client_id=CLIENT_ID,
        client_secret=CLIENT_SECRET,
        redirect_uri=REDIRECT_URI,
    )

    if token:
        spfy = spotipy.Spotify(auth=token)
        argcomplete.autocomplete(parser)
        args = parser.parse_args()
        if args.sp_name in no_args:
            args.func()
        else:
            args.func(args)
    else:
        print("Can't get token for", username)
