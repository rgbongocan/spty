#!/home/renzo/spotlite/spotlite-env/bin/python

import argparse
import inspect
import spotipy
import spotipy.util as util

CLIENT_ID = "23503e502dd54c53a15e50d8f4bc9ecc"
CLIENT_SECRET = "b69d6ad88e334a52abd05dc688ebd906"
REDIRECT_URI = "http://localhost:9090/"
SCOPES = [
    "user-read-playback-state",
    "user-read-currently-playing",
    "user-modify-playback-state",
    "user-library-read",
]

username = "count_gbrl"
spfy = None


def handle_volume(args) -> None:
    current = spfy.current_playback()["device"]["volume_percent"]
    if (volume := args.vol) == "now":
        print(current)
    elif volume == "up":
        if current == "100":
            print("Already at max volume")
        else:
            spfy.volume(min(current + 10, 100))
    elif volume == "down":
        if current == "0":
            print("Already muted")
        else:
            spfy.volume(max(0, current - 10))
    else:
        spfy.volume(volume)


def share(args) -> None:
    item = spfy.current_playback()["item"]
    if (format := args.format) in {"url", None}:
        print(item["external_urls"]["spotify"])
    if format in {"uri", None}:
        print(item["uri"])


def handle_status(args) -> None:
    playback = spfy.current_playback()
    track = playback["item"]
    title = track["name"]
    album = track["album"]["name"]
    artists = ", ".join([a["name"] for a in track["artists"]])
    if not (info := args.info):
        progress = ms_to_duration(playback["progress_ms"])
        duration = ms_to_duration(track["duration_ms"])
        label = "Artists" if len(track["artists"]) > 1 else "Artist"
        print(
            inspect.cleandoc(
                f"""
                Title: {title}
                Album: {album}
                {label}: {artists}
                {progress} / {duration}"""
            )
        )
    elif info == "track":
        print(title)
    elif info == "album":
        print(album)
    elif info == "artist":
        print(artists)


def volume_arg(arg: str) -> None:
    if arg in ["up", "down", "now"]:
        return arg
    elif arg.isdigit() and (volume := int(arg)) < 101:
        return volume
    raise argparse.ArgumentTypeError("Must be `up`, `down`, or an integer from 0-100")


def ms_to_duration(milliseconds: int) -> str:
    """
    Converts milliseconds into a human-readable duration format
    """
    seconds = milliseconds // 1000
    minutes, seconds = divmod(seconds, 60)
    return "{:02d}:{:02d}".format(minutes, seconds)


def handle_play(args) -> None:
    if t := args.track:
        track = " ".join(t)
        res = spfy.search(track, limit=1)
        if items := res["tracks"]["items"]:
            spfy.start_playback(uris=[items[0]["uri"]])
        else:
            print("No matches found")
            return
    elif a := args.album:
        album = " ".join(a)
        res = spfy.search(album, limit=1, type="album")
        if items := res["albums"]["items"]:
            spfy.start_playback(context_uri=items[0]["uri"])
        else:
            print("No matches found")
            return
    elif ls := args.list:
        playlist = " ".join(ls)
        res = spfy.search(playlist, limit=1, type="playlist")
        if items := res["playlists"]["items"]:
            spfy.start_playback(context_uri=items[0]["uri"])
        else:
            print("No matches found")
            return
    elif not spfy.current_playback()["is_playing"]:
        spfy.start_playback()


def shuffle(args) -> None:
    if (state := args.state) == "on":
        spfy.shuffle(True)
    elif state == "off":
        spfy.shuffle(False)
    else:
        spfy.shuffle(not spfy.current_playback()["shuffle_state"])


def replay(args) -> None:
    spfy.seek_track(0)


def repeat(args) -> None:
    spfy.repeat(args.state)


def pause(args) -> None:
    if spfy.current_playback()["is_playing"]:
        spfy.pause_playback()


def nxt(args) -> None:
    spfy.next_track()


def prev(args) -> None:
    spfy.previous_track()


if __name__ == "__main__":
    parser = argparse.ArgumentParser(
        prog="spotlite", description="Issue spotify commands"
    )
    subp = parser.add_subparsers(dest="sp_name")
    subp.add_parser("replay").set_defaults(func=replay)
    subp.add_parser("pause").set_defaults(func=pause)
    subp.add_parser("next").set_defaults(func=nxt)
    subp.add_parser("prev").set_defaults(func=prev)

    subp_play = subp.add_parser("play")
    subp_play.set_defaults(func=handle_play)
    subp_play.add_argument(
        "track", default="", type=str, nargs=argparse.REMAINDER, metavar="track"
    )
    group_play = subp_play.add_mutually_exclusive_group()
    group_play.add_argument("--album", type=str, nargs="+", metavar="album")
    group_play.add_argument("--list", type=str, nargs="+", metavar="list")

    subp_vol = subp.add_parser("vol")
    subp_vol.set_defaults(func=handle_volume)
    subp_vol.add_argument(
        "vol", default="now", type=volume_arg, nargs="?", metavar="vol"
    )

    subp_share = subp.add_parser("share")
    subp_share.set_defaults(func=share)
    subp_share.add_argument("format", type=str, nargs="?", choices={"url", "uri"})

    subp_status = subp.add_parser("status")
    subp_status.set_defaults(func=handle_status)
    subp_status.add_argument(
        "info", type=str, nargs="?", choices={"track", "album", "artist"}
    )

    subp_shuffle = subp.add_parser("shuffle")
    subp_shuffle.set_defaults(func=shuffle)
    subp_shuffle.add_argument("state", type=str, nargs="?", choices={"on", "off"})

    subp_repeat = subp.add_parser("repeat")
    subp_repeat.set_defaults(func=repeat)
    subp_repeat.add_argument("state", type=str, choices={"track", "context", "off"})

    token = util.prompt_for_user_token(
        username,
        scope=" ".join(SCOPES),
        client_id=CLIENT_ID,
        client_secret=CLIENT_SECRET,
        redirect_uri=REDIRECT_URI,
    )

    if token:
        spfy = spotipy.Spotify(auth=token)
        args = parser.parse_args()
        args.func(args)
    else:
        print("Can't get token for", username)
